/* Copyright 2012 Sabre Holdings */
package com.sabre.db;

import org.apache.commons.lang3.StringUtils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Set;

/**
 * An OfferingCoupon is the coupon that is attached to a offering. A coupon is a collection of redemption entries that may or may not be used as yet.
 * 
 * 
 */
public class OfferingCoupon implements Serializable
{
    /**
     * The database identifier.
     */
    private Long id;

    // Used for evaluating an offering per pricing - needs to be persisted
    // manually as is used for redemption
    private Redemption matchingRedemption = null;

    private String code;
    private OfferingCouponType couponType;

    private String encryptionKey;
    private int quantity;
    private int usedCount = 0;

    public final static int REDEMPTION_CODE_GENERATED_CHARS = 8;

    protected OfferingCoupon()
    {
    }

    public OfferingCoupon(String multiOrSingleUsePrefixCouponCode, OfferingCouponType type, int quantity)
    {
        this.code = multiOrSingleUsePrefixCouponCode;
        this.couponType = type;
        generateEncryptionKey();
        this.quantity = quantity;
    }

    private void generateEncryptionKey()
    {
        Random randomGenerator = new Random();
        Double d = Math.pow(10, 10);
        int randomInt = randomGenerator.nextInt(d.intValue());

        this.encryptionKey = Integer.toString(randomInt);
    }


    public boolean isValidRedemptionCode(String redemptionCode)
    {
        // in case of single use this.code is only a prefix (can be empty), the rest of the code is generated by RedemptionCodeService
        final boolean emptyPrefix = StringUtils.isEmpty(this.code);
        if (StringUtils.isEmpty(redemptionCode) || (emptyPrefix && !isSingleUse()))
        {
            return false;
        }

        if (isSingleUse())
        {
            return  RedemptionCodeService.isValidSingleUseRedemptionCode(redemptionCode, this.encryptionKey, this.quantity) &&
                    (emptyPrefix || this.code.equals(redemptionCode.substring(0, redemptionCode.length() - REDEMPTION_CODE_GENERATED_CHARS)));
        }

        return isMultiUse() && this.code.equals(redemptionCode);
    }

    public boolean isValidNegoFareRedemptionCode(String redemptionCode)
    {
        int quantity = 1;
        if (!isCodeValid(redemptionCode))
        {
            return false;
        }

        if (isSingleUse() || isSingleUsePerPax())
        {
            quantity = this.quantity;
        }

        return RedemptionCodeService.generateRedemptionCodes(this.code, this.id.toString(), quantity).contains(redemptionCode);
    }

    private boolean isCodeValid(String redemptionCode)
    {
        return StringUtils.isEmpty(redemptionCode) || redemptionCode.length() < REDEMPTION_CODE_GENERATED_CHARS || this.code == null;
    }




    public OfferingCouponType getOfferingCouponType()
    {
        return this.couponType;
    }

    public boolean isSingleUse()
    {
        return this.couponType.equals(OfferingCouponType.SINGLEUSE);
    }

    public boolean isSingleUsePerPax()
    {
        return this.couponType.equals(OfferingCouponType.SINGLEUSE_PER_PAX);
    }

    public boolean isMultiUse()
    {
        return this.couponType.equals(OfferingCouponType.MULTIUSE);
    }

    public boolean isMultiUsePerPax()
    {
        return this.couponType.equals(OfferingCouponType.MULTIUSE_PER_PAX);
    }

    /**
     * 
     * @return
     */
    public Long getId()
    {
        return id;
    }

    protected void setId(Long id)
    {
        this.id = id;
    }

    /**
     * A user defined code to identify this offeringCoupon.
     * 
     * @return offeringCoupon code really be not null but old implementation does not guarantee
     */
    public String getCode()
    {
        return code;
    }

    public void setCode(String code)
    {
        this.code = code;
    }

    public Redemption getMatchingRedemption()
    {
        return matchingRedemption;
    }




    public boolean isRedemptionAvailable(Redemption persistedRedemption, String code)
    {
        if (redemptionsRemain() && (isMultiUse() || isMultiUsePerPax() || persistedRedemption == null || persistedRedemption.getUsed() == null))
        {
            if (persistedRedemption != null)
            {
                if (!code.equals(persistedRedemption.getCode()))
                {
                     return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * @return coupon type type="com.eb2.qtrip.hibernate.type.OfferingCouponTypeUserType"
     */
    public OfferingCouponType getCouponType()
    {
        return couponType;
    }

    public void setCouponType(OfferingCouponType couponType)
    {
        this.couponType = couponType;
    }

    /**
     * Used to generate redemption codes
     * 
     * @return encryptionKey not-null="false" should really be not null but old implmentation does not quarantee
     */
    public String getEncryptionKey()
    {
        return encryptionKey;
    }

    protected void setEncryptionKey(String encryptionKey)
    {
        this.encryptionKey = encryptionKey;
    }

    public int getQuantity()
    {
        return quantity;
    }

    public void setQuantity(int quantity)
    {
        this.quantity = quantity;
    }

    public int getUsedCount()
    {
        return usedCount;
    }

    public void setUsedCount(int usedCount)
    {
        this.usedCount = usedCount;
    }

    public void incrementUsedCount()
    {
        this.usedCount++;
    }

    public void incrementUsedCount(int total)
    {
        this.usedCount = usedCount + total;
    }

    public void decrementUsedCount()
    {
        this.usedCount--;
    }

    public int getUnusedCount()
    {
        return this.quantity - this.usedCount;
    }

    public boolean redemptionsRemain()
    {
        return getUnusedCount() > 0;
    }

    public List<String> generateRemainingCouponCodes(Set<String> existingCodes, boolean generateCoupon)
    {
        if(generateCoupon)
        {
            return generateNegotiatedFareCoupons(existingCodes);
        }
        else
        {
            return generatePriceModifierCoupons(existingCodes);
        }
    }

    private List<String> generatePriceModifierCoupons(Set<String> existingCodes)
    {
        if (this.couponType.equals(OfferingCouponType.SINGLEUSE))
        {
            return RedemptionCodeService.generateRedemptionCodes(this.code, this.encryptionKey, this.quantity - existingCodes.size(), existingCodes);
        }
        else
        {
            return getMultiUseRedemptionCodes(existingCodes, this.code);
        }
    }



    private List<String> generateNegotiatedFareCoupons(Set<String> existingCodes)
    {
        if (this.couponType.equals(OfferingCouponType.SINGLEUSE) || this.couponType.equals(OfferingCouponType.SINGLEUSE_PER_PAX))
        {
            return RedemptionCodeService.generateRedemptionCodes(this.code, this.id.toString(), this.quantity - existingCodes.size(), existingCodes);
        }
        else
        {
            return getMultiUseRedemptionCodes(existingCodes, getRedemptionCode(existingCodes));
        }
    }


    private String getRedemptionCode(Set<String> existingCodes)
    {
        if(existingCodes.isEmpty())
        {
            List<String> redemptionCodeList = RedemptionCodeService.generateRedemptionCodes(this.code, this.id.toString(), 1, existingCodes);
            return redemptionCodeList.get(0);
        }
        else
        {
            return existingCodes.iterator().next();
        }
    }

    private List<String> getMultiUseRedemptionCodes(Set<String> existingCodes, String redemptionCode)
    {
        List<String> result = new ArrayList<String>();
        while (result.size() - existingCodes.size() < this.quantity)
        {
            result.add(redemptionCode);
        }
        return result;
    }
}
